const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./raw-CxZp5atE.js","./react-4ldeB94U.js","./drei-BQFFepro.js","./three-BIBagZx2.js","./fiber-DLnro_FV.js","./lzw-ChRl1qfm.js","./jpeg-DNgsb1kc.js","./deflate-DrAV_QZ7.js","./pako.esm-CPws4d4z.js","./packbits-Db0v2gnT.js","./lerc-Bo84uCm-.js","./webimage-k8fjy5rl.js"])))=>i.map(i=>d[i]);
import{g as Ce}from"./react-4ldeB94U.js";import{_ as M}from"./drei-BQFFepro.js";function T(s){return(e,...t)=>at(s,e,t)}function G(s,e){return T(ke(s,e).get)}const{apply:at,construct:vr,defineProperty:Lr,get:Nr,getOwnPropertyDescriptor:ke,getPrototypeOf:ce,has:Vr,ownKeys:ct,set:zr,setPrototypeOf:Kr}=Reflect,{iterator:q,species:jr,toStringTag:lt,for:qr}=Symbol,ht=Object,{create:le,defineProperty:ft,freeze:Hr,is:Yr}=ht,ut=Array,dt=ut.prototype,Me=dt[q],gt=T(Me),Re=ArrayBuffer,pt=Re.prototype;G(pt,"byteLength");const De=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:null;De&&G(De.prototype,"byteLength");const Be=ce(Uint8Array);Be.from;const E=Be.prototype;E[q];T(E.keys);T(E.values);T(E.entries);T(E.set);T(E.reverse);T(E.fill);T(E.copyWithin);T(E.sort);T(E.slice);T(E.subarray);G(E,"buffer");G(E,"byteOffset");G(E,"length");G(E,lt);const yt=Uint8Array,Fe=Uint16Array,he=Uint32Array,xt=Float32Array,j=ce([][q]()),Ge=T(j.next),mt=T(function*(){}().next),wt=ce(j),bt=DataView.prototype,It=T(bt.getUint16),fe=WeakMap,Ue=fe.prototype,ve=T(Ue.get),St=T(Ue.set),Le=new fe,Tt=le(null,{next:{value:function(){const e=ve(Le,this);return Ge(e)}},[q]:{value:function(){return this}}});function At(s){if(s[q]===Me&&j.next===Ge)return s;const e=le(Tt);return St(Le,e,gt(s)),e}const Et=new fe,Dt=le(wt,{next:{value:function(){const e=ve(Et,this);return mt(e)},writable:!0,configurable:!0}});for(const s of ct(j))s!=="next"&&ft(Dt,s,ke(j,s));const Ne=new Re(4),_t=new xt(Ne),Ot=new he(Ne),O=new Fe(512),P=new yt(512);for(let s=0;s<256;++s){const e=s-127;e<-24?(O[s]=0,O[s|256]=32768,P[s]=24,P[s|256]=24):e<-14?(O[s]=1024>>-e-14,O[s|256]=1024>>-e-14|32768,P[s]=-e-1,P[s|256]=-e-1):e<=15?(O[s]=e+15<<10,O[s|256]=e+15<<10|32768,P[s]=13,P[s|256]=13):e<128?(O[s]=31744,O[s|256]=64512,P[s]=24,P[s|256]=24):(O[s]=31744,O[s|256]=64512,P[s]=13,P[s|256]=13)}const ue=new he(2048);for(let s=1;s<1024;++s){let e=s<<13,t=0;for(;!(e&8388608);)e<<=1,t-=8388608;e&=-8388609,t+=947912704,ue[s]=e|t}for(let s=1024;s<2048;++s)ue[s]=939524096+(s-1024<<13);const U=new he(64);for(let s=1;s<31;++s)U[s]=s<<23;U[31]=1199570944;U[32]=2147483648;for(let s=33;s<63;++s)U[s]=2147483648+(s-32<<23);U[63]=3347054592;const Ve=new Fe(64);for(let s=1;s<64;++s)s!==32&&(Ve[s]=1024);function Pt(s){const e=s>>10;return Ot[0]=ue[Ve[e]+(s&1023)]+U[e],_t[0]}function ze(s,e,...t){return Pt(It(s,e,...At(t)))}var de={exports:{}};function Ke(s,e,t){const r=t&&t.debug||!1;r&&console.log("[xml-utils] getting "+e+" in "+s);const i=typeof s=="object"?s.outer:s,n=i.slice(0,i.indexOf(">")+1),a=['"',"'"];for(let o=0;o<a.length;o++){const c=a[o],l=e+"\\="+c+"([^"+c+"]*)"+c;r&&console.log("[xml-utils] pattern:",l);const f=new RegExp(l).exec(n);if(r&&console.log("[xml-utils] match:",f),f)return f[1]}}de.exports=Ke;de.exports.default=Ke;var Ct=de.exports;const te=Ce(Ct);var ge={exports:{}},pe={exports:{}},ye={exports:{}};function je(s,e,t){const i=new RegExp(e).exec(s.slice(t));return i?t+i.index:-1}ye.exports=je;ye.exports.default=je;var kt=ye.exports,xe={exports:{}};function qe(s,e,t){const i=new RegExp(e).exec(s.slice(t));return i?t+i.index+i[0].length-1:-1}xe.exports=qe;xe.exports.default=qe;var Mt=xe.exports,me={exports:{}};function He(s,e){const t=new RegExp(e,"g"),r=s.match(t);return r?r.length:0}me.exports=He;me.exports.default=He;var Rt=me.exports;const Bt=kt,re=Mt,_e=Rt;function Ye(s,e,t){const r=t&&t.debug||!1,i=!(t&&typeof t.nested===!1),n=t&&t.startIndex||0;r&&console.log("[xml-utils] starting findTagByName with",e," and ",t);const a=Bt(s,`<${e}[ 
>/]`,n);if(r&&console.log("[xml-utils] start:",a),a===-1)return;const o=s.slice(a+e.length);let c=re(o,"^[^<]*[ /]>",0);const l=c!==-1&&o[c-1]==="/";if(r&&console.log("[xml-utils] selfClosing:",l),l===!1)if(i){let u=0,d=1,y=0;for(;(c=re(o,"[ /]"+e+">",u))!==-1;){const p=o.substring(u,c+1);if(d+=_e(p,"<"+e+`[ 
	>]`),y+=_e(p,"</"+e+">"),y>=d)break;u=c}}else c=re(o,"[ /]"+e+">",0);const h=a+e.length+c+1;if(r&&console.log("[xml-utils] end:",h),h===-1)return;const f=s.slice(a,h);let g;return l?g=null:g=f.slice(f.indexOf(">")+1,f.lastIndexOf("<")),{inner:g,outer:f,start:a,end:h}}pe.exports=Ye;pe.exports.default=Ye;var Ft=pe.exports;const Gt=Ft;function $e(s,e,t){const r=[],i=t&&t.debug||!1,n=t&&typeof t.nested=="boolean"?t.nested:!0;let a=t&&t.startIndex||0,o;for(;o=Gt(s,e,{debug:i,startIndex:a});)n?a=o.start+1+e.length:a=o.end,r.push(o);return i&&console.log("findTagsByName found",r.length,"tags"),r}ge.exports=$e;ge.exports.default=$e;var Ut=ge.exports;const vt=Ce(Ut),K={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},C={};for(const s in K)K.hasOwnProperty(s)&&(C[K[s]]=parseInt(s,10));const Lt=[C.BitsPerSample,C.ExtraSamples,C.SampleFormat,C.StripByteCounts,C.StripOffsets,C.StripRowCounts,C.TileByteCounts,C.TileOffsets,C.SubIFDs],se={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},m={};for(const s in se)se.hasOwnProperty(s)&&(m[se[s]]=parseInt(s,10));const _={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,TransparencyMask:4,CMYK:5,YCbCr:6,CIELab:8,ICCLab:9},Nt={Unspecified:0,Assocalpha:1,Unassalpha:2},$r={Version:0,AddCompression:1},Xr={None:0,Deflate:1,Zstandard:2},Vt={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"};function zt(s,e){const{width:t,height:r}=s,i=new Uint8Array(t*r*3);let n;for(let a=0,o=0;a<s.length;++a,o+=3)n=256-s[a]/e*256,i[o]=n,i[o+1]=n,i[o+2]=n;return i}function Kt(s,e){const{width:t,height:r}=s,i=new Uint8Array(t*r*3);let n;for(let a=0,o=0;a<s.length;++a,o+=3)n=s[a]/e*256,i[o]=n,i[o+1]=n,i[o+2]=n;return i}function jt(s,e){const{width:t,height:r}=s,i=new Uint8Array(t*r*3),n=e.length/3,a=e.length/3*2;for(let o=0,c=0;o<s.length;++o,c+=3){const l=s[o];i[c]=e[l]/65536*256,i[c+1]=e[l+n]/65536*256,i[c+2]=e[l+a]/65536*256}return i}function qt(s){const{width:e,height:t}=s,r=new Uint8Array(e*t*3);for(let i=0,n=0;i<s.length;i+=4,n+=3){const a=s[i],o=s[i+1],c=s[i+2],l=s[i+3];r[n]=255*((255-a)/256)*((255-l)/256),r[n+1]=255*((255-o)/256)*((255-l)/256),r[n+2]=255*((255-c)/256)*((255-l)/256)}return r}function Ht(s){const{width:e,height:t}=s,r=new Uint8ClampedArray(e*t*3);for(let i=0,n=0;i<s.length;i+=3,n+=3){const a=s[i],o=s[i+1],c=s[i+2];r[n]=a+1.402*(c-128),r[n+1]=a-.34414*(o-128)-.71414*(c-128),r[n+2]=a+1.772*(o-128)}return r}const Yt=.95047,$t=1,Xt=1.08883;function Zt(s){const{width:e,height:t}=s,r=new Uint8Array(e*t*3);for(let i=0,n=0;i<s.length;i+=3,n+=3){const a=s[i+0],o=s[i+1]<<24>>24,c=s[i+2]<<24>>24;let l=(a+16)/116,h=o/500+l,f=l-c/200,g,u,d;h=Yt*(h*h*h>.008856?h*h*h:(h-16/116)/7.787),l=$t*(l*l*l>.008856?l*l*l:(l-16/116)/7.787),f=Xt*(f*f*f>.008856?f*f*f:(f-16/116)/7.787),g=h*3.2406+l*-1.5372+f*-.4986,u=h*-.9689+l*1.8758+f*.0415,d=h*.0557+l*-.204+f*1.057,g=g>.0031308?1.055*g**(1/2.4)-.055:12.92*g,u=u>.0031308?1.055*u**(1/2.4)-.055:12.92*u,d=d>.0031308?1.055*d**(1/2.4)-.055:12.92*d,r[n]=Math.max(0,Math.min(1,g))*255,r[n+1]=Math.max(0,Math.min(1,u))*255,r[n+2]=Math.max(0,Math.min(1,d))*255}return r}const Xe=new Map;function k(s,e){Array.isArray(s)||(s=[s]),s.forEach(t=>Xe.set(t,e))}async function Jt(s){const e=Xe.get(s.Compression);if(!e)throw new Error(`Unknown compression method identifier: ${s.Compression}`);const t=await e();return new t(s)}k([void 0,1],()=>M(()=>import("./raw-CxZp5atE.js"),__vite__mapDeps([0,1,2,3,4]),import.meta.url).then(s=>s.default));k(5,()=>M(()=>import("./lzw-ChRl1qfm.js"),__vite__mapDeps([5,1,2,3,4]),import.meta.url).then(s=>s.default));k(6,()=>{throw new Error("old style JPEG compression is not supported.")});k(7,()=>M(()=>import("./jpeg-DNgsb1kc.js"),__vite__mapDeps([6,1,2,3,4]),import.meta.url).then(s=>s.default));k([8,32946],()=>M(()=>import("./deflate-DrAV_QZ7.js"),__vite__mapDeps([7,8,1,2,3,4]),import.meta.url).then(s=>s.default));k(32773,()=>M(()=>import("./packbits-Db0v2gnT.js"),__vite__mapDeps([9,1,2,3,4]),import.meta.url).then(s=>s.default));k(34887,()=>M(()=>import("./lerc-Bo84uCm-.js"),__vite__mapDeps([10,8,1,2,3,4]),import.meta.url).then(async s=>(await s.zstd.init(),s)).then(s=>s.default));k(50001,()=>M(()=>import("./webimage-k8fjy5rl.js"),__vite__mapDeps([11,1,2,3,4]),import.meta.url).then(s=>s.default));function Q(s,e,t,r=1){return new(Object.getPrototypeOf(s)).constructor(e*t*r)}function Qt(s,e,t,r,i){const n=e/r,a=t/i;return s.map(o=>{const c=Q(o,r,i);for(let l=0;l<i;++l){const h=Math.min(Math.round(a*l),t-1);for(let f=0;f<r;++f){const g=Math.min(Math.round(n*f),e-1),u=o[h*e+g];c[l*r+f]=u}}return c})}function B(s,e,t){return(1-t)*s+t*e}function Wt(s,e,t,r,i){const n=e/r,a=t/i;return s.map(o=>{const c=Q(o,r,i);for(let l=0;l<i;++l){const h=a*l,f=Math.floor(h),g=Math.min(Math.ceil(h),t-1);for(let u=0;u<r;++u){const d=n*u,y=d%1,p=Math.floor(d),w=Math.min(Math.ceil(d),e-1),x=o[f*e+p],b=o[f*e+w],I=o[g*e+p],S=o[g*e+w],D=B(B(x,b,y),B(I,S,y),h%1);c[l*r+u]=D}}return c})}function er(s,e,t,r,i,n="nearest"){switch(n.toLowerCase()){case"nearest":return Qt(s,e,t,r,i);case"bilinear":case"linear":return Wt(s,e,t,r,i);default:throw new Error(`Unsupported resampling method: '${n}'`)}}function tr(s,e,t,r,i,n){const a=e/r,o=t/i,c=Q(s,r,i,n);for(let l=0;l<i;++l){const h=Math.min(Math.round(o*l),t-1);for(let f=0;f<r;++f){const g=Math.min(Math.round(a*f),e-1);for(let u=0;u<n;++u){const d=s[h*e*n+g*n+u];c[l*r*n+f*n+u]=d}}}return c}function rr(s,e,t,r,i,n){const a=e/r,o=t/i,c=Q(s,r,i,n);for(let l=0;l<i;++l){const h=o*l,f=Math.floor(h),g=Math.min(Math.ceil(h),t-1);for(let u=0;u<r;++u){const d=a*u,y=d%1,p=Math.floor(d),w=Math.min(Math.ceil(d),e-1);for(let x=0;x<n;++x){const b=s[f*e*n+p*n+x],I=s[f*e*n+w*n+x],S=s[g*e*n+p*n+x],D=s[g*e*n+w*n+x],v=B(B(b,I,y),B(S,D,y),h%1);c[l*r*n+u*n+x]=v}}}return c}function sr(s,e,t,r,i,n,a="nearest"){switch(a.toLowerCase()){case"nearest":return tr(s,e,t,r,i,n);case"bilinear":case"linear":return rr(s,e,t,r,i,n);default:throw new Error(`Unsupported resampling method: '${a}'`)}}function ir(s,e,t){let r=0;for(let i=e;i<t;++i)r+=s[i];return r}function ne(s,e,t){switch(s){case 1:if(e<=8)return new Uint8Array(t);if(e<=16)return new Uint16Array(t);if(e<=32)return new Uint32Array(t);break;case 2:if(e===8)return new Int8Array(t);if(e===16)return new Int16Array(t);if(e===32)return new Int32Array(t);break;case 3:switch(e){case 16:case 32:return new Float32Array(t);case 64:return new Float64Array(t)}break}throw Error("Unsupported data format/bitsPerSample")}function nr(s,e){return(s===1||s===2)&&e<=32&&e%8===0?!1:!(s===3&&(e===16||e===32||e===64))}function or(s,e,t,r,i,n,a){const o=new DataView(s),c=t===2?a*n:a*n*r,l=t===2?1:r,h=ne(e,i,c),f=parseInt("1".repeat(i),2);if(e===1){let g;t===1?g=r*i:g=i;let u=n*g;u&7&&(u=u+7&-8);for(let d=0;d<a;++d){const y=d*u;for(let p=0;p<n;++p){const w=y+p*l*i;for(let x=0;x<l;++x){const b=w+x*i,I=(d*n+p)*l+x,S=Math.floor(b/8),D=b%8;if(D+i<=8)h[I]=o.getUint8(S)>>8-i-D&f;else if(D+i<=16)h[I]=o.getUint16(S)>>16-i-D&f;else if(D+i<=24){const v=o.getUint16(S)<<8|o.getUint8(S+2);h[I]=v>>24-i-D&f}else h[I]=o.getUint32(S)>>32-i-D&f}}}}return h.buffer}class ar{constructor(e,t,r,i,n,a){this.fileDirectory=e,this.geoKeys=t,this.dataView=r,this.littleEndian=i,this.tiles=n?{}:null,this.isTiled=!e.StripOffsets;const o=e.PlanarConfiguration;if(this.planarConfiguration=typeof o>"u"?1:o,this.planarConfiguration!==1&&this.planarConfiguration!==2)throw new Error("Invalid planar configuration.");this.source=a}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return typeof this.fileDirectory.SamplesPerPixel<"u"?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:typeof this.fileDirectory.RowsPerStrip<"u"?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(e){return this.isTiled||(e+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-e*this.getTileHeight()}getBytesPerPixel(){let e=0;for(let t=0;t<this.fileDirectory.BitsPerSample.length;++t)e+=this.getSampleByteSize(t);return e}getSampleByteSize(e){if(e>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${e} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[e]/8)}getReaderForSample(e){const t=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1,r=this.fileDirectory.BitsPerSample[e];switch(t){case 1:if(r<=8)return DataView.prototype.getUint8;if(r<=16)return DataView.prototype.getUint16;if(r<=32)return DataView.prototype.getUint32;break;case 2:if(r<=8)return DataView.prototype.getInt8;if(r<=16)return DataView.prototype.getInt16;if(r<=32)return DataView.prototype.getInt32;break;case 3:switch(r){case 16:return function(i,n){return ze(this,i,n)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}break}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(e=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1}getBitsPerSample(e=0){return this.fileDirectory.BitsPerSample[e]}getArrayForSample(e,t){const r=this.getSampleFormat(e),i=this.getBitsPerSample(e);return ne(r,i,t)}async getTileOrStrip(e,t,r,i,n){const a=Math.ceil(this.getWidth()/this.getTileWidth()),o=Math.ceil(this.getHeight()/this.getTileHeight());let c;const{tiles:l}=this;this.planarConfiguration===1?c=t*a+e:this.planarConfiguration===2&&(c=r*a*o+t*a+e);let h,f;this.isTiled?(h=this.fileDirectory.TileOffsets[c],f=this.fileDirectory.TileByteCounts[c]):(h=this.fileDirectory.StripOffsets[c],f=this.fileDirectory.StripByteCounts[c]);const g=(await this.source.fetch([{offset:h,length:f}],n))[0];let u;return l===null||!l[c]?(u=(async()=>{let d=await i.decode(this.fileDirectory,g);const y=this.getSampleFormat(),p=this.getBitsPerSample();return nr(y,p)&&(d=or(d,y,this.planarConfiguration,this.getSamplesPerPixel(),p,this.getTileWidth(),this.getBlockHeight(t))),d})(),l!==null&&(l[c]=u)):u=l[c],{x:e,y:t,sample:r,data:await u}}async _readRaster(e,t,r,i,n,a,o,c,l){const h=this.getTileWidth(),f=this.getTileHeight(),g=this.getWidth(),u=this.getHeight(),d=Math.max(Math.floor(e[0]/h),0),y=Math.min(Math.ceil(e[2]/h),Math.ceil(g/h)),p=Math.max(Math.floor(e[1]/f),0),w=Math.min(Math.ceil(e[3]/f),Math.ceil(u/f)),x=e[2]-e[0];let b=this.getBytesPerPixel();const I=[],S=[];for(let A=0;A<t.length;++A)this.planarConfiguration===1?I.push(ir(this.fileDirectory.BitsPerSample,0,t[A])/8):I.push(0),S.push(this.getReaderForSample(t[A]));const D=[],{littleEndian:v}=this;for(let A=p;A<w;++A)for(let H=d;H<y;++H){let W;this.planarConfiguration===1&&(W=this.getTileOrStrip(H,A,0,n,l));for(let Y=0;Y<t.length;++Y){const $=Y,Ae=t[Y];this.planarConfiguration===2&&(b=this.getSampleByteSize(Ae),W=this.getTileOrStrip(H,A,Ae,n,l));const Qe=W.then(L=>{const We=L.data,et=new DataView(We),ee=this.getBlockHeight(L.y),N=L.y*f,X=L.x*h,tt=N+ee,rt=(L.x+1)*h,st=S[$],it=Math.min(ee,ee-(tt-e[3]),u-N),nt=Math.min(h,h-(rt-e[2]),g-X);for(let V=Math.max(0,e[1]-N);V<it;++V)for(let z=Math.max(0,e[0]-X);z<nt;++z){const ot=(V*h+z)*b,Ee=st.call(et,ot+I[$],v);let Z;i?(Z=(V+N-e[1])*x*t.length+(z+X-e[0])*t.length+$,r[Z]=Ee):(Z=(V+N-e[1])*x+z+X-e[0],r[$][Z]=Ee)}});D.push(Qe)}}if(await Promise.all(D),a&&e[2]-e[0]!==a||o&&e[3]-e[1]!==o){let A;return i?A=sr(r,e[2]-e[0],e[3]-e[1],a,o,t.length,c):A=er(r,e[2]-e[0],e[3]-e[1],a,o,c),A.width=a,A.height=o,A}return r.width=a||e[2]-e[0],r.height=o||e[3]-e[1],r}async readRasters({window:e,samples:t=[],interleave:r,pool:i=null,width:n,height:a,resampleMethod:o,fillValue:c,signal:l}={}){const h=e||[0,0,this.getWidth(),this.getHeight()];if(h[0]>h[2]||h[1]>h[3])throw new Error("Invalid subsets");const f=h[2]-h[0],g=h[3]-h[1],u=f*g,d=this.getSamplesPerPixel();if(!t||!t.length)for(let x=0;x<d;++x)t.push(x);else for(let x=0;x<t.length;++x)if(t[x]>=d)return Promise.reject(new RangeError(`Invalid sample index '${t[x]}'.`));let y;if(r){const x=this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,b=Math.max.apply(null,this.fileDirectory.BitsPerSample);y=ne(x,b,u*t.length),c&&y.fill(c)}else{y=[];for(let x=0;x<t.length;++x){const b=this.getArrayForSample(t[x],u);Array.isArray(c)&&x<c.length?b.fill(c[x]):c&&!Array.isArray(c)&&b.fill(c),y.push(b)}}const p=i||await Jt(this.fileDirectory);return await this._readRaster(h,t,y,r,p,n,a,o,l)}async readRGB({window:e,interleave:t=!0,pool:r=null,width:i,height:n,resampleMethod:a,enableAlpha:o=!1,signal:c}={}){const l=e||[0,0,this.getWidth(),this.getHeight()];if(l[0]>l[2]||l[1]>l[3])throw new Error("Invalid subsets");const h=this.fileDirectory.PhotometricInterpretation;if(h===_.RGB){let w=[0,1,2];if(this.fileDirectory.ExtraSamples!==Nt.Unspecified&&o){w=[];for(let x=0;x<this.fileDirectory.BitsPerSample.length;x+=1)w.push(x)}return this.readRasters({window:e,interleave:t,samples:w,pool:r,width:i,height:n,resampleMethod:a,signal:c})}let f;switch(h){case _.WhiteIsZero:case _.BlackIsZero:case _.Palette:f=[0];break;case _.CMYK:f=[0,1,2,3];break;case _.YCbCr:case _.CIELab:f=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const g={window:l,interleave:!0,samples:f,pool:r,width:i,height:n,resampleMethod:a,signal:c},{fileDirectory:u}=this,d=await this.readRasters(g),y=2**this.fileDirectory.BitsPerSample[0];let p;switch(h){case _.WhiteIsZero:p=zt(d,y);break;case _.BlackIsZero:p=Kt(d,y);break;case _.Palette:p=jt(d,u.ColorMap);break;case _.CMYK:p=qt(d);break;case _.YCbCr:p=Ht(d);break;case _.CIELab:p=Zt(d);break;default:throw new Error("Unsupported photometric interpretation.")}if(!t){const w=new Uint8Array(p.length/3),x=new Uint8Array(p.length/3),b=new Uint8Array(p.length/3);for(let I=0,S=0;I<p.length;I+=3,++S)w[S]=p[I],x[S]=p[I+1],b[S]=p[I+2];p=[w,x,b]}return p.width=d.width,p.height=d.height,p}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const e=[];for(let t=0;t<this.fileDirectory.ModelTiepoint.length;t+=6)e.push({i:this.fileDirectory.ModelTiepoint[t],j:this.fileDirectory.ModelTiepoint[t+1],k:this.fileDirectory.ModelTiepoint[t+2],x:this.fileDirectory.ModelTiepoint[t+3],y:this.fileDirectory.ModelTiepoint[t+4],z:this.fileDirectory.ModelTiepoint[t+5]});return e}getGDALMetadata(e=null){const t={};if(!this.fileDirectory.GDAL_METADATA)return null;const r=this.fileDirectory.GDAL_METADATA;let i=vt(r,"Item");e===null?i=i.filter(n=>te(n,"sample")===void 0):i=i.filter(n=>Number(te(n,"sample"))===e);for(let n=0;n<i.length;++n){const a=i[n];t[te(a,"name")]=a.inner}return t}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const e=this.fileDirectory.GDAL_NODATA;return Number(e.substring(0,e.length-1))}getOrigin(){const e=this.fileDirectory.ModelTiepoint,t=this.fileDirectory.ModelTransformation;if(e&&e.length===6)return[e[3],e[4],e[5]];if(t)return[t[3],t[7],t[11]];throw new Error("The image does not have an affine transformation.")}getResolution(e=null){const t=this.fileDirectory.ModelPixelScale,r=this.fileDirectory.ModelTransformation;if(t)return[t[0],-t[1],t[2]];if(r)return r[1]===0&&r[4]===0?[r[0],-r[5],r[10]]:[Math.sqrt(r[0]*r[0]+r[4]*r[4]),-Math.sqrt(r[1]*r[1]+r[5]*r[5]),r[10]];if(e){const[i,n,a]=e.getResolution();return[i*e.getWidth()/this.getWidth(),n*e.getHeight()/this.getHeight(),a*e.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return this.geoKeys.GTRasterTypeGeoKey===1}getBoundingBox(e=!1){const t=this.getHeight(),r=this.getWidth();if(this.fileDirectory.ModelTransformation&&!e){const[i,n,a,o,c,l,h,f]=this.fileDirectory.ModelTransformation,u=[[0,0],[0,t],[r,0],[r,t]].map(([p,w])=>[o+i*p+n*w,f+c*p+l*w]),d=u.map(p=>p[0]),y=u.map(p=>p[1]);return[Math.min(...d),Math.min(...y),Math.max(...d),Math.max(...y)]}else{const i=this.getOrigin(),n=this.getResolution(),a=i[0],o=i[1],c=a+n[0]*r,l=o+n[1]*t;return[Math.min(a,c),Math.min(o,l),Math.max(a,c),Math.max(o,l)]}}}class cr{constructor(e){this._dataView=new DataView(e)}get buffer(){return this._dataView.buffer}getUint64(e,t){const r=this.getUint32(e,t),i=this.getUint32(e+4,t);let n;if(t){if(n=r+2**32*i,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}if(n=2**32*r+i,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}getInt64(e,t){let r=0;const i=(this._dataView.getUint8(e+(t?7:0))&128)>0;let n=!0;for(let a=0;a<8;a++){let o=this._dataView.getUint8(e+(t?a:7-a));i&&(n?o!==0&&(o=~(o-1)&255,n=!1):o=~o&255),r+=o*256**a}return i&&(r=-r),r}getUint8(e,t){return this._dataView.getUint8(e,t)}getInt8(e,t){return this._dataView.getInt8(e,t)}getUint16(e,t){return this._dataView.getUint16(e,t)}getInt16(e,t){return this._dataView.getInt16(e,t)}getUint32(e,t){return this._dataView.getUint32(e,t)}getInt32(e,t){return this._dataView.getInt32(e,t)}getFloat16(e,t){return ze(this._dataView,e,t)}getFloat32(e,t){return this._dataView.getFloat32(e,t)}getFloat64(e,t){return this._dataView.getFloat64(e,t)}}class lr{constructor(e,t,r,i){this._dataView=new DataView(e),this._sliceOffset=t,this._littleEndian=r,this._bigTiff=i}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(e,t){return this.sliceOffset<=e&&this.sliceTop>=e+t}readUint8(e){return this._dataView.getUint8(e-this._sliceOffset,this._littleEndian)}readInt8(e){return this._dataView.getInt8(e-this._sliceOffset,this._littleEndian)}readUint16(e){return this._dataView.getUint16(e-this._sliceOffset,this._littleEndian)}readInt16(e){return this._dataView.getInt16(e-this._sliceOffset,this._littleEndian)}readUint32(e){return this._dataView.getUint32(e-this._sliceOffset,this._littleEndian)}readInt32(e){return this._dataView.getInt32(e-this._sliceOffset,this._littleEndian)}readFloat32(e){return this._dataView.getFloat32(e-this._sliceOffset,this._littleEndian)}readFloat64(e){return this._dataView.getFloat64(e-this._sliceOffset,this._littleEndian)}readUint64(e){const t=this.readUint32(e),r=this.readUint32(e+4);let i;if(this._littleEndian){if(i=t+2**32*r,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}if(i=2**32*t+r,!Number.isSafeInteger(i))throw new Error(`${i} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return i}readInt64(e){let t=0;const r=(this._dataView.getUint8(e+(this._littleEndian?7:0))&128)>0;let i=!0;for(let n=0;n<8;n++){let a=this._dataView.getUint8(e+(this._littleEndian?n:7-n));r&&(i?a!==0&&(a=~(a-1)&255,i=!1):a=~a&255),t+=a*256**n}return r&&(t=-t),t}readOffset(e){return this._bigTiff?this.readUint64(e):this.readUint32(e)}}const Oe=`\r
\r
`;function Ze(s){if(typeof Object.fromEntries<"u")return Object.fromEntries(s);const e={};for(const[t,r]of s)e[t.toLowerCase()]=r;return e}function hr(s){const e=s.split(`\r
`).map(t=>{const r=t.split(":").map(i=>i.trim());return r[0]=r[0].toLowerCase(),r});return Ze(e)}function fr(s){const[e,...t]=s.split(";").map(i=>i.trim()),r=t.map(i=>i.split("="));return{type:e,params:Ze(r)}}function oe(s){let e,t,r;return s&&([,e,t,r]=s.match(/bytes (\d+)-(\d+)\/(\d+)/),e=parseInt(e,10),t=parseInt(t,10),r=parseInt(r,10)),{start:e,end:t,total:r}}function ur(s,e){let t=null;const r=new TextDecoder("ascii"),i=[],n=`--${e}`,a=`${n}--`;for(let o=0;o<10;++o)r.decode(new Uint8Array(s,o,n.length))===n&&(t=o);if(t===null)throw new Error("Could not find initial boundary");for(;t<s.byteLength;){const o=r.decode(new Uint8Array(s,t,Math.min(n.length+1024,s.byteLength-t)));if(o.length===0||o.startsWith(a))break;if(!o.startsWith(n))throw new Error("Part does not start with boundary");const c=o.substr(n.length+2);if(c.length===0)break;const l=c.indexOf(Oe),h=hr(c.substr(0,l)),{start:f,end:g,total:u}=oe(h["content-range"]),d=t+n.length+l+Oe.length,y=parseInt(g,10)+1-parseInt(f,10);i.push({headers:h,data:s.slice(d,d+y),offset:f,length:y,fileSize:u}),t=d+y+4}return i}class Je{async fetch(e,t=void 0){return Promise.all(e.map(r=>this.fetchSlice(r,t)))}async fetchSlice(e){throw new Error(`fetching of slice ${e} not possible, not implemented`)}get fileSize(){return null}async close(){}}class dr extends Map{constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if(typeof e.maxAge=="number"&&e.maxAge===0)throw new TypeError("`maxAge` must be a number greater than 0");this.maxSize=e.maxSize,this.maxAge=e.maxAge||Number.POSITIVE_INFINITY,this.onEviction=e.onEviction,this.cache=new Map,this.oldCache=new Map,this._size=0}_emitEvictions(e){if(typeof this.onEviction=="function")for(const[t,r]of e)this.onEviction(t,r.value)}_deleteIfExpired(e,t){return typeof t.expiry=="number"&&t.expiry<=Date.now()?(typeof this.onEviction=="function"&&this.onEviction(e,t.value),this.delete(e)):!1}_getOrDeleteIfExpired(e,t){if(this._deleteIfExpired(e,t)===!1)return t.value}_getItemValue(e,t){return t.expiry?this._getOrDeleteIfExpired(e,t):t.value}_peek(e,t){const r=t.get(e);return this._getItemValue(e,r)}_set(e,t){this.cache.set(e,t),this._size++,this._size>=this.maxSize&&(this._size=0,this._emitEvictions(this.oldCache),this.oldCache=this.cache,this.cache=new Map)}_moveToRecent(e,t){this.oldCache.delete(e),this._set(e,t)}*_entriesAscending(){for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||this._deleteIfExpired(t,r)===!1&&(yield e)}for(const e of this.cache){const[t,r]=e;this._deleteIfExpired(t,r)===!1&&(yield e)}}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this._getItemValue(e,t)}if(this.oldCache.has(e)){const t=this.oldCache.get(e);if(this._deleteIfExpired(e,t)===!1)return this._moveToRecent(e,t),t.value}}set(e,t,{maxAge:r=this.maxAge}={}){const i=typeof r=="number"&&r!==Number.POSITIVE_INFINITY?Date.now()+r:void 0;return this.cache.has(e)?this.cache.set(e,{value:t,expiry:i}):this._set(e,{value:t,expiry:i}),this}has(e){return this.cache.has(e)?!this._deleteIfExpired(e,this.cache.get(e)):this.oldCache.has(e)?!this._deleteIfExpired(e,this.oldCache.get(e)):!1}peek(e){if(this.cache.has(e))return this._peek(e,this.cache);if(this.oldCache.has(e))return this._peek(e,this.oldCache)}delete(e){const t=this.cache.delete(e);return t&&this._size--,this.oldCache.delete(e)||t}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this._entriesAscending()],r=t.length-e;r<0?(this.cache=new Map(t),this.oldCache=new Map,this._size=t.length):(r>0&&this._emitEvictions(t.slice(0,r)),this.oldCache=new Map(t.slice(r)),this.cache=new Map,this._size=0),this.maxSize=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache){const[t,r]=e;this._deleteIfExpired(t,r)===!1&&(yield[t,r.value])}for(const e of this.oldCache){const[t,r]=e;this.cache.has(t)||this._deleteIfExpired(t,r)===!1&&(yield[t,r.value])}}*entriesDescending(){let e=[...this.cache];for(let t=e.length-1;t>=0;--t){const r=e[t],[i,n]=r;this._deleteIfExpired(i,n)===!1&&(yield[i,n.value])}e=[...this.oldCache];for(let t=e.length-1;t>=0;--t){const r=e[t],[i,n]=r;this.cache.has(i)||this._deleteIfExpired(i,n)===!1&&(yield[i,n.value])}}*entriesAscending(){for(const[e,t]of this._entriesAscending())yield[e,t.value]}get size(){if(!this._size)return this.oldCache.size;let e=0;for(const t of this.oldCache.keys())this.cache.has(t)||e++;return Math.min(this._size+e,this.maxSize)}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[r,i]of this.entriesAscending())e.call(t,i,r,this)}get[Symbol.toStringTag](){return JSON.stringify([...this.entriesAscending()])}}async function gr(s){return new Promise(e=>setTimeout(e,s))}function pr(s,e){const t=Array.isArray(s)?s:Array.from(s),r=Array.isArray(e)?e:Array.from(e);return t.map((i,n)=>[i,r[n]])}class F extends Error{constructor(e){super(e),Error.captureStackTrace&&Error.captureStackTrace(this,F),this.name="AbortError"}}class yr extends Error{constructor(e,t){super(t),this.errors=e,this.message=t,this.name="AggregateError"}}const xr=yr;class mr{constructor(e,t,r=null){this.offset=e,this.length=t,this.data=r}get top(){return this.offset+this.length}}class Pe{constructor(e,t,r){this.offset=e,this.length=t,this.blockIds=r}}class wr extends Je{constructor(e,{blockSize:t=65536,cacheSize:r=100}={}){super(),this.source=e,this.blockSize=t,this.blockCache=new dr({maxSize:r,onEviction:(i,n)=>{this.evictedBlocks.set(i,n)}}),this.evictedBlocks=new Map,this.blockRequests=new Map,this.blockIdsToFetch=new Set,this.abortedBlockIds=new Set}get fileSize(){return this.source.fileSize}async fetch(e,t){const r=[],i=[],n=[];this.evictedBlocks.clear();for(const{offset:g,length:u}of e){let d=g+u;const{fileSize:y}=this;y!==null&&(d=Math.min(d,y));const p=Math.floor(g/this.blockSize)*this.blockSize;for(let w=p;w<d;w+=this.blockSize){const x=Math.floor(w/this.blockSize);!this.blockCache.has(x)&&!this.blockRequests.has(x)&&(this.blockIdsToFetch.add(x),i.push(x)),this.blockRequests.has(x)&&r.push(this.blockRequests.get(x)),n.push(x)}}await gr(),this.fetchBlocks(t);const a=[];for(const g of i)this.blockRequests.has(g)&&a.push(this.blockRequests.get(g));await Promise.allSettled(r),await Promise.allSettled(a);const o=[],c=n.filter(g=>this.abortedBlockIds.has(g)||!this.blockCache.has(g));if(c.forEach(g=>this.blockIdsToFetch.add(g)),c.length>0&&t&&!t.aborted){this.fetchBlocks(null);for(const g of c){const u=this.blockRequests.get(g);if(!u)throw new Error(`Block ${g} is not in the block requests`);o.push(u)}await Promise.allSettled(o)}if(t&&t.aborted)throw new F("Request was aborted");const l=n.map(g=>this.blockCache.get(g)||this.evictedBlocks.get(g)),h=l.filter(g=>!g);if(h.length)throw new xr(h,"Request failed");const f=new Map(pr(n,l));return this.readSliceData(e,f)}fetchBlocks(e){if(this.blockIdsToFetch.size>0){const t=this.groupBlocks(this.blockIdsToFetch),r=this.source.fetch(t,e);for(let i=0;i<t.length;++i){const n=t[i];for(const a of n.blockIds)this.blockRequests.set(a,(async()=>{try{const o=(await r)[i],c=a*this.blockSize,l=c-o.offset,h=Math.min(l+this.blockSize,o.data.byteLength),f=o.data.slice(l,h),g=new mr(c,f.byteLength,f,a);this.blockCache.set(a,g),this.abortedBlockIds.delete(a)}catch(o){if(o.name==="AbortError")o.signal=e,this.blockCache.delete(a),this.abortedBlockIds.add(a);else throw o}finally{this.blockRequests.delete(a)}})())}this.blockIdsToFetch.clear()}}groupBlocks(e){const t=Array.from(e).sort((a,o)=>a-o);if(t.length===0)return[];let r=[],i=null;const n=[];for(const a of t)i===null||i+1===a?(r.push(a),i=a):(n.push(new Pe(r[0]*this.blockSize,r.length*this.blockSize,r)),r=[a],i=a);return n.push(new Pe(r[0]*this.blockSize,r.length*this.blockSize,r)),n}readSliceData(e,t){return e.map(r=>{let i=r.offset+r.length;this.fileSize!==null&&(i=Math.min(this.fileSize,i));const n=Math.floor(r.offset/this.blockSize),a=Math.floor(i/this.blockSize),o=new ArrayBuffer(r.length),c=new Uint8Array(o);for(let l=n;l<=a;++l){const h=t.get(l),f=h.offset-r.offset,g=h.top-i;let u=0,d=0,y;f<0?u=-f:f>0&&(d=f),g<0?y=h.length-u:y=i-h.offset-u;const p=new Uint8Array(h.data,u,y);c.set(p,d)}return o})}}class we{get ok(){return this.status>=200&&this.status<=299}get status(){throw new Error("not implemented")}getHeader(e){throw new Error("not implemented")}async getData(){throw new Error("not implemented")}}class be{constructor(e){this.url=e}async request({headers:e,signal:t}={}){throw new Error("request is not implemented")}}class br extends we{constructor(e){super(),this.response=e}get status(){return this.response.status}getHeader(e){return this.response.headers.get(e)}async getData(){return this.response.arrayBuffer?await this.response.arrayBuffer():(await this.response.buffer()).buffer}}class Ir extends be{constructor(e,t){super(e),this.credentials=t}async request({headers:e,signal:t}={}){const r=await fetch(this.url,{headers:e,credentials:this.credentials,signal:t});return new br(r)}}class Sr extends we{constructor(e,t){super(),this.xhr=e,this.data=t}get status(){return this.xhr.status}getHeader(e){return this.xhr.getResponseHeader(e)}async getData(){return this.data}}class Tr extends be{constructRequest(e,t){return new Promise((r,i)=>{const n=new XMLHttpRequest;n.open("GET",this.url),n.responseType="arraybuffer";for(const[a,o]of Object.entries(e))n.setRequestHeader(a,o);n.onload=()=>{const a=n.response;r(new Sr(n,a))},n.onerror=i,n.onabort=()=>i(new F("Request aborted")),n.send(),t&&(t.aborted&&n.abort(),t.addEventListener("abort",()=>n.abort()))})}async request({headers:e,signal:t}={}){return await this.constructRequest(e,t)}}const ie={};class Ar extends we{constructor(e,t){super(),this.response=e,this.dataPromise=t}get status(){return this.response.statusCode}getHeader(e){return this.response.headers[e]}async getData(){return await this.dataPromise}}class Er extends be{constructor(e){super(e),this.parsedUrl=ie.parse(this.url),this.httpApi=(this.parsedUrl.protocol==="http:",ie)}constructRequest(e,t){return new Promise((r,i)=>{const n=this.httpApi.get({...this.parsedUrl,headers:e},a=>{const o=new Promise(c=>{const l=[];a.on("data",h=>{l.push(h)}),a.on("end",()=>{const h=Buffer.concat(l).buffer;c(h)}),a.on("error",i)});r(new Ar(a,o))});n.on("error",i),t&&(t.aborted&&n.destroy(new F("Request aborted")),t.addEventListener("abort",()=>n.destroy(new F("Request aborted"))))})}async request({headers:e,signal:t}={}){return await this.constructRequest(e,t)}}class Ie extends Je{constructor(e,t,r,i){super(),this.client=e,this.headers=t,this.maxRanges=r,this.allowFullFile=i,this._fileSize=null}async fetch(e,t){return this.maxRanges>=e.length?this.fetchSlices(e,t):(this.maxRanges>0&&e.length>1,Promise.all(e.map(r=>this.fetchSlice(r,t))))}async fetchSlices(e,t){const r=await this.client.request({headers:{...this.headers,Range:`bytes=${e.map(({offset:i,length:n})=>`${i}-${i+n}`).join(",")}`},signal:t});if(r.ok)if(r.status===206){const{type:i,params:n}=fr(r.getHeader("content-type"));if(i==="multipart/byteranges"){const f=ur(await r.getData(),n.boundary);return this._fileSize=f[0].fileSize||null,f}const a=await r.getData(),{start:o,end:c,total:l}=oe(r.getHeader("content-range"));this._fileSize=l||null;const h=[{data:a,offset:o,length:c-o}];if(e.length>1){const f=await Promise.all(e.slice(1).map(g=>this.fetchSlice(g,t)));return h.concat(f)}return h}else{if(!this.allowFullFile)throw new Error("Server responded with full file");const i=await r.getData();return this._fileSize=i.byteLength,[{data:i,offset:0,length:i.byteLength}]}else throw new Error("Error fetching data.")}async fetchSlice(e,t){const{offset:r,length:i}=e,n=await this.client.request({headers:{...this.headers,Range:`bytes=${r}-${r+i}`},signal:t});if(n.ok)if(n.status===206){const a=await n.getData(),{total:o}=oe(n.getHeader("content-range"));return this._fileSize=o||null,{data:a,offset:r,length:i}}else{if(!this.allowFullFile)throw new Error("Server responded with full file");const a=await n.getData();return this._fileSize=a.byteLength,{data:a,offset:0,length:a.byteLength}}else throw new Error("Error fetching data.")}get fileSize(){return this._fileSize}}function Se(s,{blockSize:e,cacheSize:t}){return e===null?s:new wr(s,{blockSize:e,cacheSize:t})}function Dr(s,{headers:e={},credentials:t,maxRanges:r=0,allowFullFile:i=!1,...n}={}){const a=new Ir(s,t),o=new Ie(a,e,r,i);return Se(o,n)}function _r(s,{headers:e={},maxRanges:t=0,allowFullFile:r=!1,...i}={}){const n=new Tr(s),a=new Ie(n,e,t,r);return Se(a,i)}function Or(s,{headers:e={},maxRanges:t=0,allowFullFile:r=!1,...i}={}){const n=new Er(s),a=new Ie(n,e,t,r);return Se(a,i)}function Pr(s,{forceXHR:e=!1,...t}={}){return typeof fetch=="function"&&!e?Dr(s,t):typeof XMLHttpRequest<"u"?_r(s,t):Or(s,t)}function Cr(s,e){let t=s.length-e,r=0;do{for(let i=e;i>0;i--)s[r+e]+=s[r],r++;t-=e}while(t>0)}function kr(s,e,t){let r=0,i=s.length;const n=i/t;for(;i>e;){for(let o=e;o>0;--o)s[r+e]+=s[r],++r;i-=e}const a=s.slice();for(let o=0;o<n;++o)for(let c=0;c<t;++c)s[t*o+c]=a[(t-c-1)*n+o]}function Mr(s,e,t,r,i,n){if(!e||e===1)return s;for(let c=0;c<i.length;++c){if(i[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(i[c]!==i[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const a=i[0]/8,o=n===2?1:i.length;for(let c=0;c<r&&!(c*o*t*a>=s.byteLength);++c){let l;if(e===2){switch(i[0]){case 8:l=new Uint8Array(s,c*o*t*a,o*t*a);break;case 16:l=new Uint16Array(s,c*o*t*a,o*t*a/2);break;case 32:l=new Uint32Array(s,c*o*t*a,o*t*a/4);break;default:throw new Error(`Predictor 2 not allowed with ${i[0]} bits per sample.`)}Cr(l,o)}else e===3&&(l=new Uint8Array(s,c*o*t*a,o*t*a),kr(l,o,a))}return s}class Zr{async decode(e,t){const r=await this.decodeBlock(t),i=e.Predictor||1;if(i!==1){const n=!e.StripOffsets,a=n?e.TileWidth:e.ImageWidth,o=n?e.TileLength:e.RowsPerStrip||e.ImageLength;return Mr(r,i,a,o,e.BitsPerSample,e.PlanarConfiguration)}return r}}function ae(s){switch(s){case m.BYTE:case m.ASCII:case m.SBYTE:case m.UNDEFINED:return 1;case m.SHORT:case m.SSHORT:return 2;case m.LONG:case m.SLONG:case m.FLOAT:case m.IFD:return 4;case m.RATIONAL:case m.SRATIONAL:case m.DOUBLE:case m.LONG8:case m.SLONG8:case m.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${s}`)}}function Rr(s){const e=s.GeoKeyDirectory;if(!e)return null;const t={};for(let r=4;r<=e[3]*4;r+=4){const i=Vt[e[r]],n=e[r+1]?K[e[r+1]]:null,a=e[r+2],o=e[r+3];let c=null;if(!n)c=o;else{if(c=s[n],typeof c>"u"||c===null)throw new Error(`Could not get value of geoKey '${i}'.`);typeof c=="string"?c=c.substring(o,o+a-1):c.subarray&&(c=c.subarray(o,o+a),a===1&&(c=c[0]))}t[i]=c}return t}function R(s,e,t,r){let i=null,n=null;const a=ae(e);switch(e){case m.BYTE:case m.ASCII:case m.UNDEFINED:i=new Uint8Array(t),n=s.readUint8;break;case m.SBYTE:i=new Int8Array(t),n=s.readInt8;break;case m.SHORT:i=new Uint16Array(t),n=s.readUint16;break;case m.SSHORT:i=new Int16Array(t),n=s.readInt16;break;case m.LONG:case m.IFD:i=new Uint32Array(t),n=s.readUint32;break;case m.SLONG:i=new Int32Array(t),n=s.readInt32;break;case m.LONG8:case m.IFD8:i=new Array(t),n=s.readUint64;break;case m.SLONG8:i=new Array(t),n=s.readInt64;break;case m.RATIONAL:i=new Uint32Array(t*2),n=s.readUint32;break;case m.SRATIONAL:i=new Int32Array(t*2),n=s.readInt32;break;case m.FLOAT:i=new Float32Array(t),n=s.readFloat32;break;case m.DOUBLE:i=new Float64Array(t),n=s.readFloat64;break;default:throw new RangeError(`Invalid field type: ${e}`)}if(e===m.RATIONAL||e===m.SRATIONAL)for(let o=0;o<t;o+=2)i[o]=n.call(s,r+o*a),i[o+1]=n.call(s,r+(o*a+4));else for(let o=0;o<t;++o)i[o]=n.call(s,r+o*a);return e===m.ASCII?new TextDecoder("utf-8").decode(i):i}class Br{constructor(e,t,r){this.fileDirectory=e,this.geoKeyDirectory=t,this.nextIFDByteOffset=r}}class J extends Error{constructor(e){super(`No image at index ${e}`),this.index=e}}class Fr{async readRasters(e={}){const{window:t,width:r,height:i}=e;let{resX:n,resY:a,bbox:o}=e;const c=await this.getImage();let l=c;const h=await this.getImageCount(),f=c.getBoundingBox();if(t&&o)throw new Error('Both "bbox" and "window" passed.');if(r||i){if(t){const[d,y]=c.getOrigin(),[p,w]=c.getResolution();o=[d+t[0]*p,y+t[1]*w,d+t[2]*p,y+t[3]*w]}const u=o||f;if(r){if(n)throw new Error("Both width and resX passed");n=(u[2]-u[0])/r}if(i){if(a)throw new Error("Both width and resY passed");a=(u[3]-u[1])/i}}if(n||a){const u=[];for(let d=0;d<h;++d){const y=await this.getImage(d),{SubfileType:p,NewSubfileType:w}=y.fileDirectory;(d===0||p===2||w&1)&&u.push(y)}u.sort((d,y)=>d.getWidth()-y.getWidth());for(let d=0;d<u.length;++d){const y=u[d],p=(f[2]-f[0])/y.getWidth(),w=(f[3]-f[1])/y.getHeight();if(l=y,n&&n>p||a&&a>w)break}}let g=t;if(o){const[u,d]=c.getOrigin(),[y,p]=l.getResolution(c);g=[Math.round((o[0]-u)/y),Math.round((o[1]-d)/p),Math.round((o[2]-u)/y),Math.round((o[3]-d)/p)],g=[Math.min(g[0],g[2]),Math.min(g[1],g[3]),Math.max(g[0],g[2]),Math.max(g[1],g[3])]}return l.readRasters({...e,window:g})}}class Te extends Fr{constructor(e,t,r,i,n={}){super(),this.source=e,this.littleEndian=t,this.bigTiff=r,this.firstIFDOffset=i,this.cache=n.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(e,t){const r=this.bigTiff?4048:1024;return new lr((await this.source.fetch([{offset:e,length:typeof t<"u"?t:r}]))[0],e,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(e){const t=this.bigTiff?20:12,r=this.bigTiff?8:2;let i=await this.getSlice(e);const n=this.bigTiff?i.readUint64(e):i.readUint16(e),a=n*t+(this.bigTiff?16:6);i.covers(e,a)||(i=await this.getSlice(e,a));const o={};let c=e+(this.bigTiff?8:2);for(let f=0;f<n;c+=t,++f){const g=i.readUint16(c),u=i.readUint16(c+2),d=this.bigTiff?i.readUint64(c+4):i.readUint32(c+4);let y,p;const w=ae(u),x=c+(this.bigTiff?12:8);if(w*d<=(this.bigTiff?8:4))y=R(i,u,d,x);else{const b=i.readOffset(x),I=ae(u)*d;if(i.covers(b,I))y=R(i,u,d,b);else{const S=await this.getSlice(b,I);y=R(S,u,d,b)}}d===1&&Lt.indexOf(g)===-1&&!(u===m.RATIONAL||u===m.SRATIONAL)?p=y[0]:p=y,o[K[g]]=p}const l=Rr(o),h=i.readOffset(e+r+t*n);return new Br(o,l,h)}async requestIFD(e){if(this.ifdRequests[e])return this.ifdRequests[e];if(e===0)return this.ifdRequests[e]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[e];if(!this.ifdRequests[e-1])try{this.ifdRequests[e-1]=this.requestIFD(e-1)}catch(t){throw t instanceof J?new J(e):t}return this.ifdRequests[e]=(async()=>{const t=await this.ifdRequests[e-1];if(t.nextIFDByteOffset===0)throw new J(e);return this.parseFileDirectoryAt(t.nextIFDByteOffset)})(),this.ifdRequests[e]}async getImage(e=0){const t=await this.requestIFD(e);return new ar(t.fileDirectory,t.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let e=0,t=!0;for(;t;)try{await this.requestIFD(e),++e}catch(r){if(r instanceof J)t=!1;else throw r}return e}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const t="GDAL_STRUCTURAL_METADATA_SIZE=",r=t.length+100;let i=await this.getSlice(e,r);if(t===R(i,m.ASCII,t.length,e)){const a=R(i,m.ASCII,r,e).split(`
`)[0],o=Number(a.split("=")[1].split(" ")[0])+a.length;o>r&&(i=await this.getSlice(e,o));const c=R(i,m.ASCII,o,e);this.ghostValues={},c.split(`
`).filter(l=>l.length>0).map(l=>l.split("=")).forEach(([l,h])=>{this.ghostValues[l]=h})}return this.ghostValues}static async fromSource(e,t,r){const i=(await e.fetch([{offset:0,length:1024}],r))[0],n=new cr(i),a=n.getUint16(0,0);let o;if(a===18761)o=!0;else if(a===19789)o=!1;else throw new TypeError("Invalid byte order value.");const c=n.getUint16(2,o);let l;if(c===42)l=!1;else if(c===43){if(l=!0,n.getUint16(4,o)!==8)throw new Error("Unsupported offset byte-size.")}else throw new TypeError("Invalid magic number.");const h=l?n.getUint64(8,o):n.getUint32(4,o);return new Te(e,o,l,h,t)}close(){return typeof this.source.close=="function"?this.source.close():!1}}async function Jr(s,e={},t){return Te.fromSource(Pr(s,e),t)}export{Zr as B,$r as L,Xr as a,Jr as f};
